---
title: 'Integrating Next.js with Express.js using Auth0 for Authentication'
author: 'Ben Chavez'
description: 'Learn how to integrate a Next.js 13 frontend with a custom backend Express.js server API using Auth0 for authentication. This tutorial assumes some basic knowledge of Next.js and Express.js and that you have an Auth0 account set up.'
summary: 'This article provides a step-by-step guide to integrating a Next.js 13 frontend with a custom backend Express.js server API using Auth0 for authentication. The article assumes some basic knowledge of Next.js and Express.js and that the reader has an Auth0 account set up. The tutorial covers topics such as rewrites, middleware, and more.'
keywords: Next.js, Express.js, Auth0, Authentication, Integration, Rewrite, Middleware.
publishedAt: '2024-10-10'
updatedAt: '2024-10-10'
---

In this post, I am going to walk you through the process of integrating a Next.js 13 (Next.js App directory) frontend with a custom backend Express.js server API. I will be using Auth0 for authentication in this example, but the process would be similar for other auth providers.

Between Vercel's push towards serverless functions (No worries, I'm still a Vercel fanboy. For now...), and the seemingly widespread adoption of tRPC by much of the Typescript community, I have found the documentation on how to integrate your own backend API with the new Next.js app directory to be a bit sparse.

Now in many cases, if you are using Next.js with Typescript, it probably makes sense to use serverless functions and if you want full type-safety, then it would make sense to use tRPC too.

However, in my case, there were a few reasons why I didn't want to use serverless or tRPC:

1. I honestly just wanted more practice with writing REST APIs.
2. I have yet to determine if this is unfounded, but I didn't really feel like working around cold starts as I expect my user base to start small and grow over time.
3. If my application does gain traction, I didn't want to lock myself into using Typescript+node.js just because I implemented the MVP using tRPC.

With that said, I do intend on learning those technologies in the future and advise that you also have some good reasons if you are going to build your application with a traditional API server.

I am going to assume that you have some basic knowledge of Next.js and Express.js and that you have an Auth0 account set up with a Next.js application. If not, here are some helpful resources to get you to that point:

- Express.js:
  - [Creating A Typescript Express.Js Web Application With ES6 - Step-By-Step Guide](https://benjamin-chavez.com/blog/creating-a-typescript-express.js-web-application-with-es6-step-by-step-guide/)
- Next.js + auth0:
  - [A Comprehensive Guide to Next.js Authentication with Auth0](https://javascript.plainenglish.io/a-comprehensive-guide-to-next-js-authentication-with-auth0-c5af1e472fdb)
  - [Add Login to your Next.js application](https://auth0.com/docs/quickstart/webapp/nextjs/interactive)

Now, if you want to code along, you can find the branch with the starter code on my GitHub [here](https://github.com/benjamin-chavez/nextjs-express-auth0-template/tree/blog-post-starter-code).

In this example, I will have the express server stored in a `server` folder and the Next.js app in a `client` folder. You can run them individually in their own terminals, or in a single terminal using [concurrently](https://www.npmjs.com/package/concurrently) in the root directory.

## Start Application

We will start by getting the base project running locally.

1. Clone the starter code:

```bash
git clone -b blog-post-starter-code git@github.com:benjamin-chavez/nextjs-express-auth0-template.git
cd nextjs-express-auth0-template
```

2. Set up the Environment Variables:

```bash
cp ./client/.env.local.example ./client/.env.local
cp ./server/.env.example ./server/.env
```

Be sure to update your Next.js environment variables with your Auth0 application. The update file should look something like this:

```bash
# client/.env.local

AUTH0_SECRET='e2ebaf05e08f75b2eb3605ce28e6bf3ef0e68c54d9672ec87b4e69fae2f38460'
AUTH0_BASE_URL='http://localhost:3000'
AUTH0_ISSUER_BASE_URL='https://dev-mqyygar8pnsvarul.us.auth0.com'
AUTH0_CLIENT_ID='oMv0Lmf1v2uTITiqQ67hhRJBL4XKdhO4'
AUTH0_CLIENT_SECRET='I_CFaneP_CyYQ-WBvXzwVlZKjsv4qL9YzY-hE8FE9HrsDNNtCJJnyp5s0vtt_yg1'
```

3. Install the project dependencies:

```bash
# From the root directory
pnpm i
```

4. Open two separate terminals: start the frontend in one and the backend in the other.

   - Start the Next.js frontend app

   ```bash
    cd client
    pnpm dev
   ```

   - Start the Express.js backend server

   ```bash
   cd server
   pnpm start
   ```

Now, if you open your browser to [http://localhost:3000](http://localhost:3000) and [http://localhost:5000/api](http://localhost:5000/api), you will see the following:

<Image
  src="/img/blog/auth0-nextjs-express/ss1.png"
  width="718"
  height="404"
  alt="Screenshot"
/>

## Declare Rewrites

In Next.js a [rewrite](https://nextjs.org/docs/app/api-reference/next-config-js/rewrites) allows us to map any incoming navigation or client request paths to a different destination path.

We are going to use rewrites to map all incoming API requests over to our express server path.

Now, with both your frontend and backend running, go to [http://localhost:3000/api](http://localhost:3000/api) in your browser. You will see a `404 page not found` error.

Stop your Next.js client-server and add the following code to your `client/next.config.js` file.

```js:client/next.config.js {3-10} showLineNumbers
/** @type {import('next').NextConfig} */
const nextConfig = {
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: 'http://localhost:5000/api/:path*',
      },
    ];
  },
};

module.exports = nextConfig;
```

Start up your Next.js client server again and <strong>go back to</strong> [http://localhost:3000/api](http://localhost:3000/api) in your browser.

The `404` should be gone, and you should now see `Server Running...`:

<Image
  src="/img/blog/auth0-nextjs-express/ss3.png"
  width="718"
  height="404"
  alt="Screenshot"
/>

This message is coming directly from your **Express.js** server because our request has been mapped from the source path of `http://localhost:3000/api` to the destination path of `http://localhost:5000/api`.

Before we continue, we need to add one more rewrite rule so that our requests to the Auth0 API are excluded from being rewritten:

```js:client/next.config.js {5-8} showLineNumbers
/** @type {import('next').NextConfig} */
const nextConfig = {
  async rewrites() {
    return [
      {
        source: '/api/auth/:path',
        destination: '/api/auth/:path*',
      },
      {
        source: '/api/:path*',
        destination: 'http://localhost:5000/api/:path*',
      },
    ];
  },
};

module.exports = nextConfig;
```

## Add Next.js Middleware

Rather than requiring authentication in each of our private pages or components, we will be implementing [Next.js Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware). This will allow us to specify the specific routes that we want to make private.

{/* TODO: Cleanup */}
There are several benefits to this approach. The primary benefit is that it enables client-side handling of authentication and authorization in our **Next.js** application, as opposed to server-side handling in our **Express.js** server. If we were to have the authentication in our server, then we would be sending requests each time a user navigated to a new page and waiting for our server responses before allowing the user to continue. You can imagine how this might become problematic.

This approach allows us to keep our auth logic separate from our other **application** logic. This separation of concerns is a good design choice as the **modularity** reduces cognitive load and if later we decide to change auth managers, we only have to update one file as opposed to having to update every private page/component.

1. Create a new `client/src/middleware.ts` file and add the following contents:

```ts:client/src/middleware.ts {} showLineNumbers
import { withMiddlewareAuthRequired } from '@auth0/nextjs-auth0/edge';

export default withMiddlewareAuthRequired();

export const config = {};
```

If you open your browser back to [http://localhost:3000](http://localhost:3000), you will be automatically redirected to the **Auth0** login screen.

<Image
  src="/img/blog/auth0-nextjs-express/ss2.png"
  width="718"
  height="404"
  alt="Screenshot"
/>

This is because we have effectively protected all routes. The function `withMiddlewareAuthRequired()` informs Next.js and Auth0 that authentication is required for all requests processed by the middleware. Meanwhile, the pattern `matcher: '/:path*',` specifies which route requests should be processed by the middleware. In our case, it's all routes.

If you log in or sign up, you will again have access to all of the pages of our application.

2. Define protected routes

Now, we don't actually want to make the whole app private, so let's update our `matcher` pattern as follows:

```ts:client/src/middleware.ts {6} showLineNumbers
import { withMiddlewareAuthRequired } from '@auth0/nextjs-auth0/edge';

export default withMiddlewareAuthRequired();

export const config = {
  matcher: ['/private/:path*'],
};
```

Ensure you are logged out and go back to [http://localhost:3000](http://localhost:3000), you should have access to both our `Home` and `Public` pages. Additionally, if you navigate to [http://localhost:3000/private](http://localhost:3000/private), you will once again be redirected to our login screen.

<Callout emoji="üìù">

You cannot access the Next.js middleware from server components.

Next.js **middleware** only runs on _navigated routes_ and _API requests from **client components**_.

</Callout>

## Protecting Our API Routes

If you return to [http://localhost:3000/api](http://localhost:3000/api), you will notice that you need to be logged in to see our `Server Running...` response. This is because we passed our API routes to our middleware matcher with `'/api/:path*'`.

This is important as it prevents unauthorized users from bypassing our security simply by hitting our API routes instead of our frontend UI.

However, there is still a massive security flaw in our design. If you navigate to [http://localhost:5000/api](http://localhost:5000/api), you will see that our route isn't actually protected.

We know this because we are able to see the `Server Running...` response.

To remedy this, we need to add our API to Auth0 and add authentication to the route in our Express server code.

1. In your Auth0 dashboard go to `Applications>APIs`.

<Image
  src="/img/blog/auth0-nextjs-express/ss8.png"
  width="718"
  height="404"
  alt="Screenshot"
/>

2. Click the `+ Create API button` and update the form's Name and Identifier fields before clicking create:

   - **Name:** Express.js Server
   - **Identifier:** http://localhost:5000/api
   - **Signing Algorithm:** RS256

<Image
  src="/img/blog/auth0-nextjs-express/ss9.png"
  width="718"
  height="404"
  alt="Screenshot"
/>

3. Update your Environment Variables

   - Copy the `AUTH0_ISSUER_BASE_URL` environment variable from the `client/.env.local` file and add it to `server/.env`

   - Create a new `AUTH0_AUDIENCE` env variable and set it equal to the identifer from the previous step:

```bash:server/.env {3,4} showLineNumbers
PORT=5000

AUTH0_ISSUER_BASE_URL='https://dev-mqyygar8pnsvarul.us.auth0.com'
AUTH0_AUDIENCE=http://localhost:5000/api
```

```bash:client/.env.local {16-17} showLineNumbers
# Secret key for Auth0 - To generate, run `openssl rand -hex 32` in the command line
AUTH0_SECRET='e2ebaf05e08f75b2eb3605ce28e6bf3ef0e68c54d9672ec87b4e69fae2f38460'

# The base URL for your application
AUTH0_BASE_URL='http://localhost:3000'

# Your Auth0 tenant domain
AUTH0_ISSUER_BASE_URL='https://dev-mqyygar8pnsvarul.us.auth0.com'

# Your Auth0 client ID
AUTH0_CLIENT_ID='Hdyjm0UaxA4siHztbgIdU5POnJlgfeLm'

# Your Auth0 client secret
AUTH0_CLIENT_SECRET='vZ1tRndqiVqLUD7UYFH2d4XWGQOw4jNjuj7Abd45BmMNlmCyaVNapERUE3r9KpsQ'

# The audience that the Auth0 ID token is intended for
AUTH0_AUDIENCE=http://localhost:5000/api
```

Now that we've added our API to Auth0 we can add authentication directly to our server routes.

1. In your Express.js server directory, install the following npm packages:

```bash
#  ENSURE YOU ARE IN YOUR SERVER DIRECTORY
cd server
pnpm i express-jwt jwks-rsa
```

2. Create this middleware file `server/src/middleware/authMiddleware.ts` in your backend.

```ts:server/src/middleware/authMiddleware.ts showLineNumbers
import 'dotenv/config';

import { GetVerificationKey, expressjwt as jwt } from 'express-jwt';
import jwksRsa from 'jwks-rsa';
const issuerBaseUrl = process.env.AUTH0_ISSUER_BASE_URL;
const audience = process.env.AUTH0_AUDIENCE || 'http://localhost:5000/';

export const checkJwt = jwt({
  secret: jwksRsa.expressJwtSecret({
    cache: true,
    rateLimit: true,
    jwksRequestsPerMinute: 5,
    jwksUri: `${issuerBaseUrl}/.well-known/jwks.json`,
  }) as GetVerificationKey,
  audience: audience,
  issuer: `${issuerBaseUrl}/`,
  algorithms: ['RS256'],
});
```

We will use this auth middleware in our backend to decrypt `JWT Authentication Tokens` that our Express.js server receives from our Next.js frontend.

3. In your `server/src/app.ts` file import the auth middleware and add it to your API routes:

```ts:src/app.ts {1, 5} showLineNumbers
import { checkJwt } from './middleware/authMiddleware';
...

// Be sure to add the `checkJwt` middleware here:
app.use('/api', checkJwt, routes);
app.get('/api/private-route', checkJwt, (req, res) => {
  res.status(200).send(listEndpoints(app));
});
...
```

If we open back up to [http://localhost:5000/api](http://localhost:5000/api), we will see that our backend API routes are now protected as well.

<Image
  src="/img/blog/auth0-nextjs-express/ss4.png"
  width="718"
  height="404"
  alt="Screenshot"
/>

## Add CORS (optional)

For this specifici example, adding CORS is not required because our API requests have been rewritten. TODO: essentially sidestepping TODO: a browser-enforced security measure and doesn't apply to server-to-server communication.

However, it is good practice to add CORS so that we save our future selves from creating unnecesary bugs.

1. Copy over the `AUTH0_BASE_URL` Environment variable from your next.js app's `.env.local` file and paste it into your Express Server's `.env` file:

```bash:server/.env {5} showLineNumbers
PORT=5000

AUTH0_ISSUER_BASE_URL='https://dev-q514l5sgo7t68du7.us.auth0.com'
AUTH0_AUDIENCE=http://localhost:5000/api
AUTH0_BASE_URL=http://localhost:3000
```

2. Install the CORS npm package on your server:

```bash
pnpm i cors
```

3. Update the imports and add `cors` middleware to your server's `app.ts` file:

```ts:server/src/app.ts {1, 3, 17, 20} showLineNumbers
import 'dotenv/config';

import cors from 'cors';
import cookieParser from 'cookie-parser';
import express from 'express';
import flash from 'express-flash';
import morgan from 'morgan';
import {
  generalErrorHandler,
  notFoundHandler,
} from './middleware/errorMiddleware';
import listEndpoints from 'express-list-endpoints';
import routes from './routes/index';
import { checkJwt } from './middleware/authMiddleware';

const app = express();
const baseUrl = process.env.AUTH0_BASE_URL;

app.use(morgan('dev'));
app.use(cors({ origin: baseUrl }));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());
app.use(flash());

app.use('/api', checkJwt, routes);
app.get('/api/private-route', checkJwt, (req, res) => {
  res.status(200).send(listEndpoints(app));
});

app.use(notFoundHandler);
app.use(generalErrorHandler);

export default app;

```

## Securely passing Auth Tokens

So far, this is great, we have both our frontend and backend protected. The only problem is that now we have to pass auth tokens to our API to gain access to our protected routes.

This is easy if we are making requests from a server component, we just get the auth token from our session and pass it with the request:

```tsx:example-server-component.tsx showLineNumbers
// THIS IS EXAMPLE CODE ONLY AND WILL NOT USED IN OUR APPLICATION
import { getAccessToken } from '@auth0/nextjs-auth0';

export async function getMyProducts() {
  const { accessToken } = await getAccessToken();

  const res = await fetch(`http://localhost:5000/api`, {
    method: 'GET',
    headers: {
      Authorization: `Bearer ${accessToken}`,
    },
  });

  return res.json();
}
```

The issue is that client components cannot use `getAccessToken()`. We _could_ get the access token in a server component and pass it as props to our client component. That would work, but it isn't the most secure solution as we would be sending the auth token to the client.

A more secure solution is to add the authToken to our API Request's headers in our frontend middleware before `rewriting` our requests to our backend API.

Up to now, we have bean manually creating our requests in our browser. So to set this up we will need to create a request that we can attach our authentication token to.

1. Convert the `Private` page to a client component by adding the `'use client';` directive to the top of the file.

```tsx:client/src/app/private/page.tsx {1} showLineNumbers
'use client';
```

2. Import the `useState` hook and write a `callApi()` function to fetch data from our Express server.

```tsx:client/src/app/private/page.tsx {3-35} showLineNumbers
'use client';

import { useState } from 'react';

export default function PrivatePage() {
  const [state, setState] = useState({
    isLoading: false,
    response: undefined,
    error: undefined,
  });

  const callApi = async () => {
    setState((previous) => ({ ...previous, isLoading: true }));

    try {
      const response = await fetch('/api/private-route');
      const data = await response.json();

      setState((previous) => ({
        ...previous,
        response: data,
        error: undefined,
      }));
    } catch (error) {
      setState((previous) => ({
        ...previous,
        response: undefined,
        error,
      }));
    } finally {
      setState((previous) => ({ ...previous, isLoading: false }));
    }
  };

  const { isLoading, response, error } = state;
  ...
}
```

3. Add a button that we can use to initiate API requests

```tsx:client/src/app/private/page.tsx {1, 8-12} showLineNumbers
    return (
      <>
        <h1 className="mt-10 text-4xl font-bold tracking-tight text-white sm:text-6xl">
          Private Page
        </h1>

        <button
          onClick={callApi}
          className="block rounded hover:opacity-70 text-white bg-pink-800/50 px-2 py-1 mt-10"
        >
          Call API
        </button>
      </>
    );
```

4. Ensure we are not in a `loading state` and display the server response

```tsx:client/src/app/private/page.tsx {1, 15-17} showLineNumbers
  if (!isLoading) {
    return (
      <>
        <h1 className="mt-10 text-4xl font-bold tracking-tight text-white sm:text-6xl">
          Private Page
        </h1>

        <button
          onClick={callApi}
          className="block rounded hover:opacity-70 text-white bg-pink-800/50 px-2 py-1 mt-10"
        >
          Call API
        </button>

        <div className="mt-20">
          {response && <div>{JSON.stringify(response)}</div>}
        </div>
      </>
    );
  }
```

Your fully updated `Private` page should look like this:

```tsx:client/src/app/private/page.tsx {} showLineNumbers
'use client';

import { useState } from 'react';

export default function PrivatePage() {
  const [state, setState] = useState({
    isLoading: false,
    response: undefined,
    error: undefined,
  });

  const callApi = async () => {
    setState((previous) => ({ ...previous, isLoading: true }));

    try {
      const response = await fetch('/api/routes');
      const data = await response.json();

      setState((previous) => ({
        ...previous,
        response: data,
        error: undefined,
      }));
    } catch (error) {
      setState((previous) => ({
        ...previous,
        response: undefined,
        error,
      }));
    } finally {
      setState((previous) => ({ ...previous, isLoading: false }));
    }
  };

  const { isLoading, response, error } = state;

  if (!isLoading) {
    return (
      <>
        <h1 className="mt-10 text-4xl font-bold tracking-tight text-white sm:text-6xl">
          Private Page
        </h1>

        <button
          onClick={callApi}
          className="mt-10 block rounded bg-pink-800/50 px-2 py-1 text-white hover:opacity-70"
        >
          Call API
        </button>

        <div className="mt-20">
          {response && <div>{JSON.stringify(response)}</div>}
        </div>
      </>
    );
  }
}
```

Now back in your browser, if you login and go to `http://localhost:3000/private`, you should see the updated Private page with the new `Call API` button.

<Image
  src="/img/blog/auth0-nextjs-express/ss5.png"
  width="718"
  height="404"
  alt="Screenshot"
/>

## Set Authentication Headers

Next, we will want to add our authentication token to the headers of our private request as it passes through our middleware.

1. Create a custom middleware function as an argument to `withMiddlewareAuthRequired()`.

   The new custom middleware function should take in a `NextRequest` object, copy any existing headers over to a new `NextResponse` object, and return that `NextResponse` object.

```ts:client/src/middleware.ts {1-11} showLineNumbers
export default withMiddlewareAuthRequired(function middleware(
  req: NextRequest,
) {
  const response = NextResponse.next({
    request: {
      headers: new Headers(req.headers),
    },
  });

  return response;
});
```

2. Import `getSession` to get our user session and auth token from Auth0

```ts:client/src/middleware.ts {1, 6, 15-16} showLineNumbers
import { getSession, withMiddlewareAuthRequired } from '@auth0/nextjs-auth0/edge';

...

// Be sure to add the `async` modifier to your function
export default withMiddlewareAuthRequired(async function middleware(
  req: NextRequest
) {
  const response = NextResponse.next({
    request: {
      headers: new Headers(req.headers),
    },
  });

  const user = await getSession(req, response);
  const token = user?.accessToken;

  return response;
});
...
```

3. Set the Authorization header in our newly created `NextResponse` object:

```ts {3} showLineNumbers
const token = user?.accessToken;

response.headers.set('Authorization', `Bearer ${token}`);

return response;
```

The fully updated middleware will look like this:

```ts:client/src/middleware.ts showLineNumbers
import {
  getSession,
  withMiddlewareAuthRequired,
} from '@auth0/nextjs-auth0/edge';
import { NextRequest, NextResponse } from 'next/server';

export default withMiddlewareAuthRequired(async function middleware(
  req: NextRequest,
) {
  const response = NextResponse.next({
    request: {
      headers: new Headers(req.headers),
    },
  });

  const user = await getSession(req, response);
  const token = user?.accessToken;

  response.headers.set('Authorization', `Bearer ${token}`);

  return response;
});

export const config = {
  matcher: ['/private/:path*', '/api/:path*'],
};
```

Now, if we go to our private page and click our `Call API` button, we will see the response data object being displayed on our `Private` page:

<Image
  src="/img/blog/auth0-nextjs-express/ss6.png"
  width="718"
  height="404"
  alt="Screenshot"
/>

In this article, we learned how to integrate a Next.js 13 frontend with a custom backend Express.js server API using Auth0 for authentication. We covered topics such as setting up a custom backend server, configuring Auth0 for authentication, and integrating the backend with the frontend using rewrites and middleware. By following the steps outlined in this tutorial, you should now have a solid understanding of how to integrate Next.js with Express.js using Auth0 for authentication.

The final code for this post is saved in this [GitHub repo](). If you found this helpful, give the repo a star! ‚≠ê

The content in this post was something that I learned and implemented as part of the development of my startup `Audio Archive`, which is a multi-vendor marketplace, built with node.js, for music producers to buy and sell Digital Audio Workstation (DAW) files.

If you enjoyed this post, stay tuned as I will continue documenting what I learn in the development of `Audio Archive`. Lastly, if you would like to see the WIP of that project you can find the code here: [github.com/benjamin-chavez/AudioArchive](https://github.com/benjamin-chavez/AudioArchive).
